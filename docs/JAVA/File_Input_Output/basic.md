---
sidebar_position: 1
---

# 基础

**Java** 拥有一个灵活但有些复杂的 **I/O 库**，允许程序员处理各种不同的 I/O 情况。

核心模型基于**装饰者模式 decorator pattern**，并采用了**面向对象**的 I/O 方法。

## 流 stream

一个流 streams 可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。

这些 input streams 对原始输入进行转换。然后，可以通过某种类型的读取器来解释经过转换的输入，从而呈现出转换后的信息。

对于 output，过程基本上是相反的，使用一个 writer 将数据通过 output streams 传递，这些输出流修改数据，然后将其写入目标。

这对于复杂的转换来说可能相当繁琐，但对于基于字符的简单 I/O，我们可以大大简化事情。

Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。

## I/O

我们已经经常使用了一种形式的 I/O：终端 I/O。

在我们所见过的内容中，Scanner 是一个读取器，它在 InputStream 上操作。

我们一直在给它提供 System.in 来使用，这是一个输入流，其源是底层计算机系统提供的基本输入通道。

对于输出，我们一直在使用 System.out，这是一个输出流和写入器（实际类型为 PrintStream），它将字符写入底层操作系统输出通道，无论它是什么。

从文件中读取字符和写入字符是如此重要的用例，以至于我们还提供了类似简化的基本文件 I/O 方法。

Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。

Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。

## Try-With-Resources

I/O 可能会生成许多已检查的异常，我们有责任通过将它们传播到调用链中来处理这些异常，或者使用 try-catch 来处理它们。在所有 I/O 情况下，即使生成了异常，我们可能也希望执行一些操作，例如在流上调用 close()。

这表明我们希望将调用 close() 放在 finally 块中，但这会产生自己的问题，因为 finally 是一个与 try 块不同的上下文，所以我们面临一个关于在哪里创建读取器或写入器以及一堆嵌套的 try-catch 结构的困境，或者可能没有正确关闭流（在某些情况下可能会导致额外的数据丢失，或者使文件被锁定等）。

为了解决这个问题，Java 引入了一个（相对较新的）功能称为“try-with”。这允许使用不同块的上下文中可用的资源对 try-catch 进行参数化。由于它是用于 I/O 资源的，它还会自动关闭资源，无需显式的 finally 块（除非您想在 finally 中执行其他操作）。

在[这篇中查看 try-with 的例子](./fileReading)
